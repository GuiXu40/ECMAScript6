# -------------------------对象的拓展-----------------------
## 目录
<p id="title"></p>
<a href="#p1">:snowflake:属性的简洁表示法</a><br>
<a href="#p2">:snowflake:属性名表达式</a><br>
<a href="#p3">:snowflake:方法的name属性</a><br>
<a href="#p4">:snowflake:Object.is()</a><br>
<a href="#p5">:snowflake:Object.assign()</a><br>
<a href="#p6">:snowflake:属性的可枚举性</a><br>
<a href="#p7">:snowflake:属性的遍历</a><br>
<a href="#p8">:snowflake:__proto__,Object.setPrototypeOf(),Object.getPrototypeOf()</a><br>
<a href="#p9">:snowflake:Object.key(),Object.value().Object.entries()</a><br>
<a href="#p10">:snowflake:对象的拓展运算符</a><br>
<a href="#p11">:snowflake:Object.getOwnPrototypeDescriptors()</a><br>
<a href="#p12">:snowflake:Null运算符</a><br>
<p id="p1"></p>

## :sunny:属性的简洁表示法
<a href="#title">:whale2:回到目录</a><br>
ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
```JavaScript
let age = 18;
let id = '2018110210';


let student = {
  'name' : 'guixu',
  age,
  id
}

alert(student.name);    //guixu
alert(student.id);      //2018110210
alert(student.age);     //18
```
上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。
```javascript
function studnts(name,id,age){
  return {name,id,age};     //返回一个对象
}

var s1 = studnts('guixu','2018110210',18);
 
alert(s1.name);     //guixu
alert(s1.id);       //2018110210
alert(s1.age);      //18
```
上面的函数返回的一个对象，对象里面的name,id,age就相当于属性值，参数值传入属性值。除了属性简写，方法也可以简写。
```JavaScript
let person = {
  say(text){
    alert(text);
  }
}

person.say("Hello!");
```
在ES5方法都是像这样写的：
```JavaScript
let person = {
    say : function(text){
      alert(text);
    }
}

person.say("Hello!");
```
可以看出使用属性的简洁表示法可以帮助我们简化许多工作。这种写法用于函数的返回值，将会非常方便。
```JavaScript
function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
```
CommonJS 模块输出一组变量，就非常合适使用简洁写法。
```JavaScript
let ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
```
属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。
```JavaScript
const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value < this._wheels) {
      throw new Error('数值太小了！');
    }
    this._wheels = value;
  }
}
```
注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。
```JavaScript
const obj = {
  class () {}
};

// 等同于

var obj = {
  'class': function() {}
};
```
上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。

如果某个方法的值是一个 Generator 函数，前面需要加上星号。
```JavaScript
const obj = {
  * m() {
    yield 'hello world';
  }
};
```
<p id="p2"></p>

## :sunny:属性名表达式
<a href="#title">:whale2:回到目录</a><br>
JavaScript 定义对象的属性，有两种方法。
```JavaScript
// 方法一
obj.foo = 123;

// 方法二
obj['foo'] = 123;
```
上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。
```JavaScript
let point = {
   x : 2,        //直接定义属性名
   'y' : 3,      //字符型定义
   ['r'] : 1,    //方括号事定义
}

alert(point.x+","+point.y);    //2,3
alert(point.r);                //1
```
表达式还可以用于定义方法名。
```JavaScript
let point = {
   x : 2,
   'y' : 3,
   ['r'] : 1,
   ['show'](){
      alert(this.x+","+this.y);
   }
}

point.show();
```
注意，属性名表达式与简洁表示法，不能同时使用，会报错。
```JavaScript
// 报错
const foo = 'bar';
const bar = 'abc';
const baz = { [foo] };

// 正确
const foo = 'bar';
const baz = { [foo]: 'abc'};
```
注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。
```JavaScript
const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject // Object {[object Object]: "valueB"}
```
上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。
<p id="p33"></p>

## :sunny:方法的name属性
<a href="#title">:whale2:回到目录</a><br>
函数的name属性返回函数名,对象方法也是函数,因此也有name属性
```JavaScript
const person = {
    sayName() {
        console.log("hello");
    },
};

person.sayName.name;  //"sayName"
```
如果对象的方法使用了取值函数(getter)和存值函数(setter),则name属性不是在该方法上面,而是在该方法属性描述对象的get和set属性上面,返回值是方法名前加上get和set
```JavaScript
const obj = {
    get foo(){},
    set foo(x){}
};

obj.foo.name   //报错,name of  undefined

const descriptor = Object.getOwnPropertyDescriptor(obj,'foo');

descriptor.get.name  //"get foo"
descriptor.set.name  //"set foo"
```
**有两种特殊方法**: bind方法创造的函数,name属性放回"bound"加上原函数的名字;Function构造函数创造的函数,name属性返回"anonymous"
```javascript
(new Function()).name //"anonymous"

var doSomething = function() {

};
doSomething.bind().name //"bound deSomething"
```
如果对象的方法是一个Symbol值,那么name属性返回的是这个Symbol值的描述
```JavaScript
const key1 = Symbol('hello');
const key3 = Symbol();
let obj ={
    [key1](){},
    [key2](){},
};
obj[key1].name  //[hello]
obj[key2].name  //""
```

<p id="p4"></p>

## :sunny:Object.is()
<a href="#title">:whale2:回到目录</a><br>
ES5比较两个值是否相等,只有两个运算符:*相等运算符(==),和严格相等运算符(===)*,缺点就是**前者会自动转换数据类型,后者的NaN不等于自身,以及+0等于-0**.<br>
为了解决这个问题,ES6提出了Object.is()方法,用来比较两个值是否严格相等,与严格相等运算符(===)的行为基本一致
```JavaScript
Object.is('foo','foo')  //true
Object.is({},{})  //false
```
不同之处在于两个: **+0不等于-0,NaN等于自身**
```JavaScript
+0===-0  //true
NaN===NaN  //false

Object.is(+0,-0);  //false
Object.is(NaN,NaN);  //true
```
ES5可以通过下面的代码部署Object.is
```javascript
Object.defineProperty(Object,'is',{
    value: function(x,y){
        if(x===y){
            return x!=0 || 1/x===1/y;
        }
        return x!==x && y!==y;
    },
    configurable : true.
    enumerable : false,
    writable: true
});
```
<p id="p5"></p>

## :sunny:Object.assign()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p6"></p>

## :sunny:属性的可枚举性
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p7"></p>

## :sunny:属性的遍历
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p8"></p>

## :sunny:__proto__,Object.setPrototypeOf(),Object.getPrototypeOf()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p9"></p>

## :sunny:Object.key(),Object.value().Object.entries()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p10"></p>

## :sunny:对象的拓展运算符
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p11"></p>

## :sunny:Object.getOwnPrototypeDescriptors()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p12"></p>

## :sunny:Null运算符
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
