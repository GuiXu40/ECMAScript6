# ---------------------数组的拓展-----------------------
## 目录
<p id="title"></p>
<a href="#p1">:snowflake:拓展运算符</a><br>
<a href="#p2">:snowflake:Array.from()</a><br>
<a href="#p3">:snowflake:Array.of()</a><br>
<a href="#p4">:snowflake:数组实例的copyWithin()</a><br>
<a href="#p5">:snowflake:数组实例的find()和findIndex()</a><br>
<a href="#p6">:snowflake:数组实例的fill()</a><br>
<a href="#p7">:snowflake:数组实例的entires(),keys(),values()</a><br>
<a href="#p8">:snowflake:数组实例的include()</a><br>
<a href="#p9">:snowflake:数组的空位</a><br>
<p id="p1"></p>

## :sunny:拓展运算符
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:含义
扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
```JavaScript
var a = [...[1,2,3,4]];

alert(a[0]);       //1
alert(a.length);   //4
alert(a.push(5,6));
alert(a);          //123456
```
可以看出这个运算符就是声明数组的另一种形式。

该运算符主要用于函数调用。
```JavaScript
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
```
上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。

扩展运算符与正常的函数参数可以结合使用，非常灵活。
```JavaScript
function f(v, w, x, y, z) { }
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
扩展运算符后面还可以放置表达式。

const arr = [
  ...(x > 0 ? ['a'] : []),
  'b',
];
```
如果扩展运算符后面是一个空数组，则不产生任何效果。
```JavaScript
[...[], 1]
// [1]
```
注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
```JavaScript
(...[1, 2])
// Uncaught SyntaxError: Unexpected number

console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number

console.log(...[1, 2])
// 1 2
```
上面前两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而第三种情况console.log(...[1, 2])就不会报错，因为这时是函数调用。
#### :mag_right:代替数组的apply方法
由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
```JavaScript
// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);
```
apply()方法第一参数为null，第二参数为数组，意为把数组的值传入函数作为参数,注意这样不改变原数组的值
```JavaScript
function f(x, y, z) {
     x = x + 1;
     y = y + 1;
     z = z + 1;
  }
  let args = [0, 1, 2];
  f(...args);

  alert(args);          //0，1，2
  ```
这种方法可以应对多参数情况，比如求任意多个参数中的最大值：
```JavaScript
var a = Math.max(...[5,3,2,8,9]);
var b = Math.max(...[4,2,5]);

alert(a);      //9
alert(b);      //5
```
还可以像下面这样
```JavaScript
// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
```
上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。

另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。
```JavaScript
// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);
```
上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。

下面是另外一个例子。
```JavaScript
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```
#### :mag_right:拓展运算符的应用
+ 合并数组:<br>
数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。
```JavaScript
const a1 = [1, 2];
const a2 = a1;

a2[0] = 2;
a1 // [2, 2]
```
上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。

ES5 只能用变通方法来复制数组。
```JavaScript
const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
```
上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。

扩展运算符提供了复制数组的简便写法。
```JavaScript
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```
上面的两种写法，a2都是a1的克隆。
+ 与解构赋值结合<br>
扩展运算符可以与解构赋值结合起来，用于生成数组。
```JavaScript
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
```
下面是另外一些例子。
```JavaScript
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = ["foo"];
first  // "foo"
rest   // []
```
如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
```JavaScript
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
```
可以对上面的理解还不是很充分，如果学习过数据结构，其实就知道上面这种形式是取表头与取表尾，都知道表尾是一个线性表，表头只有一个元素，可以为表可以为一个表元素，但是表尾一定是个表。所以像上面的例子，表头只有一个元素，表尾是很多项所以为rest类型的值
+ 函数的返回值<br>
JavaScript的函数只能返回一个值,如果需要返回多个值,只能返回数组或对象.拓展运算符提供了解决这个问题的一种变通方法
```JavaScript
var dateFields=readDateFields(database);
var d=new Date(...dateFields);
```
上面的代码从数据库取出一行数据,通过拓展运算符,直接将其传入构造函数Date
+ 字符串<br>
扩展运算符还可以将字符串转为真正的数组。
```JavaScript
[...'hello']
// [ "h", "e", "l", "l", "o" ]
```
上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。
```JavaScript
'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
```
上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。
```JavaScript
function length(str) {
  return [...str].length;
}

length('x\uD83D\uDE80y') // 3
```
凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。
```JavaScript
let str = 'x\uD83D\uDE80y';

str.split('').reverse().join('')
// 'y\uDE80\uD83Dx'

[...str].reverse().join('')
// 'y\uD83D\uDE80x'
```
上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确
+ 实现了lterator<br>
任何lterator接口的对象(详情见14章<a href="014-lterator和for...ofx循环">lterator</a>)都可以通过拓展运算符转换为真正的数组
```JavaScript
var nodeList=document.querySelectorAll('div');
var array=[...nodeList];
```
上面的代码中,querySelectorAll方法返回的是一个nodeList对象,不是数组,而是一个类似数组的对象.拓展运算符可以将其转换为真正的数组-->**原因在于NodeList对象实现了Lterator**,对于那些没有部署lterator接口的类似数组的对象,拓展运算符就无法将其转换为真正的数组了,但是可以使用Array.from方法
+ Map和Set结构,Generator函数<br>
拓展运算符调用的是数据结构的Iterator接口,因此只要具备Iterator接口的对象,都可以使用拓展运算符,入Map结构
```JavaScript
let map=new Map([
    [1,'one'],
    [2,'two'],
    [3,'three'],
]);

let arr=[...map.keys()];//[1,2,3]
```
Generator函数运行后会返回一个遍历器对象,因此也可以使用拓展运算符
```JavaScript
var go = function*(){
    yield 1;
    yield 2;
    yield 3;
};

[...go()]  //[1,2,3]
```
<p id="p2"></p>

## :sunny:Array.from()
<a href="#title">:whale2:回到目录</a><br> 
Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。

下面是一个类似数组的对象，Array.from将它转为真正的数组。
```JavaScript
let arr = {
    length: 3,
    '0': 'a',
    '1': 'b',
    '2': 'c',
     3 : 'd',
    'four' : 'e'
    
};

// ES5的写法
var arr1 = [].slice.call(arr); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arr); // ['a', 'b', 'c']
```
要想上面对象解析为数组成功，一定要注意几个点，第一必须有length属性，第二必须有字符串‘0’，‘1’...‘n’等索引项，没有引号的索引项无效如上面的3，以及不是数字的four均无效。最重要的本质一点就是有length属性，只要有都可以转换为数组。

实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
```JavaScript
// NodeList对象
let ps = document.querySelectorAll('p');
Array.from(ps).filter(p => {
  return p.textContent.length > 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
```
上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。

只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。
```JavaScript
Array.from('hello')
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
```
上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。

如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。
```JavaScript
Array.from([1, 2, 3])
// [1, 2, 3]
```
值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。
```JavaScript
// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
```
扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。
```JavaScript
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```
上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。

对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。
```JavaScript
const toArray = (() =>
  Array.from ? Array.from : obj => [].slice.call(obj)
)();
```
Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
```JavaScript
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```
下面的例子是取出一组 DOM 节点的文本内容。
```JavaScript
let spans = document.querySelectorAll('span.name');

// map()
let names1 = Array.prototype.map.call(spans, s => s.textContent);

// Array.from()
let names2 = Array.from(spans, s => s.textContent)
```
下面的例子将数组中布尔值为false的成员转为0。
```JavaScript
Array.from([1, , 2, , 3], (n) => n || 0)
// [1, 0, 2, 0, 3]
```
另一个例子是返回各种数据的类型。
```JavaScript
function typesOf () {
  return Array.from(arguments, value => typeof value)
}
typesOf(null, [], NaN)
// ['object', 'object', 'number']
```
如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。

Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。
```JavaScript
Array.from({ length: 2 }, () => 'jack')
// ['jack', 'jack']
```
上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。

Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。
```JavaScript
function countSymbols(string) {
  return Array.from(string).length;
}
<p id="p3"></p>
```
## :sunny:Array.of()
<a href="#title">:whale2:回到目录</a><br>
Array.of方法用于将一组值，转换为数组。
```JavaScript
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```
上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。

Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。
```JavaScript
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```
Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

Array.of方法可以用下面的代码模拟实现。
```JavaScript
function ArrayOf(){
  return [].slice.call(arguments);
}
<p id="p4"></p>
```
## :sunny:数组实例的copyWithin()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p5"></p>

## :sunny:数组实例的find()和findIndex()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p6"></p>

## :sunny:数组实例的fill()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p7"></p>

## :sunny:数组实例的entires(),keys(),values()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p8"></p>

## :sunny:数组实例的include()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p9"></p>

## :sunny:数组的空位
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
