# ---------------------数组的拓展-----------------------
## 目录
<p id="title"></p>
<a href="#p1">:snowflake:拓展运算符</a><br>
<a href="#p2">:snowflake:Array.from()</a><br>
<a href="#p3">:snowflake:Array.of()</a><br>
<a href="#p4">:snowflake:数组实例的copyWithin()</a><br>
<a href="#p5">:snowflake:数组实例的find()和findIndex()</a><br>
<a href="#p6">:snowflake:数组实例的fill()</a><br>
<a href="#p7">:snowflake:数组实例的entires(),keys(),values()</a><br>
<a href="#p8">:snowflake:数组实例的include()</a><br>
<a href="#p9">:snowflake:数组的空位</a><br>
<p id="p1"></p>

## :sunny:拓展运算符
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:含义
扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
```JavaScript
var a = [...[1,2,3,4]];

alert(a[0]);       //1
alert(a.length);   //4
alert(a.push(5,6));
alert(a);          //123456
```
可以看出这个运算符就是声明数组的另一种形式。

该运算符主要用于函数调用。
```JavaScript
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
```
上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。

扩展运算符与正常的函数参数可以结合使用，非常灵活。
```JavaScript
function f(v, w, x, y, z) { }
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
扩展运算符后面还可以放置表达式。

const arr = [
  ...(x > 0 ? ['a'] : []),
  'b',
];
```
如果扩展运算符后面是一个空数组，则不产生任何效果。
```JavaScript
[...[], 1]
// [1]
```
注意，扩展运算符如果放在括号中，JavaScript 引擎就会认为这是函数调用。如果这时不是函数调用，就会报错。
```JavaScript
(...[1, 2])
// Uncaught SyntaxError: Unexpected number

console.log((...[1, 2]))
// Uncaught SyntaxError: Unexpected number

console.log(...[1, 2])
// 1 2
```
上面前两种情况都会报错，因为扩展运算符所在的括号不是函数调用，而第三种情况console.log(...[1, 2])就不会报错，因为这时是函数调用。
#### :mag_right:代替数组的apply方法
由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。
```JavaScript
// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);
```
apply()方法第一参数为null，第二参数为数组，意为把数组的值传入函数作为参数,注意这样不改变原数组的值
```JavaScript
function f(x, y, z) {
     x = x + 1;
     y = y + 1;
     z = z + 1;
  }
  let args = [0, 1, 2];
  f(...args);

  alert(args);          //0，1，2
  ```
这种方法可以应对多参数情况，比如求任意多个参数中的最大值：
```JavaScript
var a = Math.max(...[5,3,2,8,9]);
var b = Math.max(...[4,2,5]);

alert(a);      //9
alert(b);      //5
```
还可以像下面这样
```JavaScript
// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
```
上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。

另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。
```JavaScript
// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);
```
上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。

下面是另外一个例子。
```JavaScript
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
```
#### :mag_right:拓展运算符的应用
<p id="p2"></p>

## :sunny:Array.from()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p3"></p>

## :sunny:Array.of()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p4"></p>

## :sunny:数组实例的copyWithin()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p5"></p>

## :sunny:数组实例的find()和findIndex()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p6"></p>

## :sunny:数组实例的fill()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p7"></p>

## :sunny:数组实例的entires(),keys(),values()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p8"></p>

## :sunny:数组实例的include()
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
<p id="p9"></p>

## :sunny:数组的空位
<a href="#title">:whale2:回到目录</a><br>
#### :mag_right:
